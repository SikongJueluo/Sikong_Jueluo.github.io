[{"id":"768ab94bc5574df04ac4541ddb03daf1","title":"C语言基础学习笔记 --- 持续更新中...","content":"序言main函数main函数的基本信息函数顾名思义其实与数学的函数类似，只不过C语言的函数是更为广义的函数，表示为一种处理问题的方法。下面是函数的常见形式，且下面的函数是主函数。\nint main(void)\n&#123;\n\treturn 0；\n&#125;\n其中：int部分是返回类型。main部分是函数名，类似数学函数中的f、g。void部分是参数，类似于数学函数中的自变量，如f（x，y）。return 0；表示返回一个0的数值。\n关于返回类型，是用于告诉计算机函数返回值的类型，如：整型、浮点型、字符型、无返回（实际上无返回不代表真的无返回，知道即可）。类似于数学的整数、小数。更详细的解释看下面的变量。\n在此，只需了解到此即可。重点是记住主函数的基本形式。缺斤少两不一定不能运行，但这是一个不好的习惯。\nmain函数的作用对于一个程序，我们通常会存放很多函数。如果我们直接将一个程序从头到尾执行，必然会导致很多问题，比如：我们无法多次使用同一个函数，他的逻辑会非常混乱，难以移植等等。\n因此C语言规定，在初始化完成后，程序只执行main函数里的内容，如果其中调用到其他函数，则再跳到其他函数执行里面的内容，并将返回值返回给主函数或其他函数。\n\n变量与赋值变量的定义在程序中，我们通常需要一些变量来存储一些数值，来计算。这与数学中的变量类似。\n变量的类型由于计算机的存储的原理，我们无法像现实一般，将变量表示成为任何类型。计算机存储的变量通常是有界的。因此我们将变量分为不同类型，方便计算机识别。\n\n\n\n变量类型\n定义符\n范围\n例子\n\n\n\n整型\nint\n-32,768 到 32,767\n2\n\n\n长整型\nlong，long int\n-2,147,483,648 到 2,147,483,647\n666666\n\n\n单浮点型\nfloat\n1.2E-38 到 3.4E+38\n3.14\n\n\n双浮点型\ndouble\n2.3E-308 到 1.7E+308\n\n\n\n长双浮点型\nlong double\n3.4E-4932 到 1.1E+4932\n\n\n\n字符型\nchar\n-128 到 127\n哈哈6\n\n\n在此简单的叙述一下变量的类型，实际上还能更加细分，剩下的内容，如：细分类型、范围、存储原理等，请自行查询。\n变量的存储类型默认为auto。\n变量的初始化下面为变量的初始化。\nunsigned int number &#x3D; 0;\nchar character &#x3D; &quot;Hello World!&quot;;\nfloat little, small;\n\n通常，初始化一个变量的步骤为：（修饰）+  定义符 + 变量名 + （初始化的数值）\n值得注意的是，我们可以单独定义变量而不用初始化。即：int number;\n我们也可以定义多个变量，变量中间用,隔开。\n对于字符型，我们规定使用&quot;&quot;表示一句话或单个字符，用&#39;&#39;表示单个字符。\n我们还可以用unsigned修饰定义符，表示无符号，即非负。用unsigned修饰时，变量类型的范围也会发生变化。\n变量的赋值变量的赋值是自右向左的，即右边的值（以后简称右值）赋予给左边的值（以后简称左值）。\nint num &#x3D; 0;\nnum &#x3D; 1;\n\n运算与数学类似的我们用+表示相加，-表示相减，*表示相乘，/表示相除，%表示求余。\n注意事项一、类型转换不同类型变量进行运算，低级类型的变量会先转换成高级类型的变量，再进行运算，最后再转换成要赋值的变量的类型。字符串无法转换，但单个字符会根据ASCII码转换成相应的整型。\n在C语言中，浮点数比整数高级，范围越大的越高级，但低于int类型的都会转换成int类型再计算。\n常量的小数默认是double型。\nint num1 &#x3D; 66;\nfloat num2 &#x3D; 0;\nnum2 &#x3D; 1.0 * num1;\n&#x2F;&#x2F;在这里num1会转换成double型，再相乘\n&#x2F;&#x2F;最后转换成float型赋予给num2\n\n二、运算符+等于号对于运算符加等于号，表示左值与右值先运算，然后再赋予给左值。\nint num &#x3D; 0;\nwhile(1)\n&#123;\n\tnum++;\n\tnum %&#x3D; 3;\n&#125;\n\n&#x2F;&#x2F;在此num先求其除3的余数，再将余数赋值给num\n&#x2F;&#x2F;常用于限制num的自增\n\n三、求余的限制在C语言中，只能对整数求余，如果需要对小数求余，则需要调用math.h 中的fmod函数。\n四、自增&#x2F;自减符++表示变量递增1，–表示变量递减1。自增&#x2F;自减可以放于变量前，表示先加&#x2F;减再用；放于变量变量后，先用再加&#x2F;减。我们常用自增和自减优化算法。\nint num1 &#x3D; 6, num2 &#x3D; 7;\nprintf(&quot;%d, %d&quot;, num1++, --num2);\n&#x2F;**输出结果**&#x2F;\n6, 6\n\n\n\nstdio.h库文件C语言规定.h文件为库文件，库之所以叫库，是因为其中有别人写好的函数，你调用便可以使用。达到一定水平后，我们也可以自己写自己的库。\n调用函数之前我们认识到函数会有返回值，函数名及参数。对于定义一个函数或写主函数，这些都是必不可少的。\n但在调用函数时，我们只用像数学一般，直接调用，输入参数即可使用。如果我们要获取其返回值，我们只用将其赋值给变量即可。假如该函数无参数需要输入，那也要带上括号，让编译器知道这是个函数。\na &#x3D; pow(10, 6);\nprintf(&quot;Hello World&quot;);\n\nprintfprintf的作用printf的字面意思就是打印，即将文字输出到输出缓冲区（一段系统特定的内存）中，表现为输出文字。\n格式控制符printf拥有多个参数，具体数目根据格式控制符所定。如下所示：\nprintf(&quot;result &#x3D; %+d&quot;, sum);\nprintf(&quot;average &#x3D; %#4.2lf, pow &#x3D; %#d&quot;, avg, num);\nprintf(&quot;该方程无解&quot;);\n\n观察就可以知道所谓的格式控制符，就是 %??? ,一般而言，格式控制符的格式如下：\n%[标志][输出最小宽度][.精度][类型长度]类型\n方框[]的部分表示可选。\n之所以要有标识符，其实是告诉程序应该在哪打印变量，没有标识符他就会打印出字符，而非变量的值。\n标志符标 志意义-结果左对齐，右边填空格0输出的字符长度不够时，用0补全+输出符号(正号或负号)空格输出值为正时冠以空格，为负时冠以负号#对c、s、d、u类无影响； 对o类，在输出时加前缀o； 对x类，在输出时加前缀0x； 对e、g、f 类当结果有小数时才给出小数点。\n\n对于标志符，现实中少用到，了解即可。\n&#x2F;**标志符 - 和 0 放在第二部分最小宽度处演示**&#x2F;\n\n&#x2F;**标志符 + 演示**&#x2F;\nint num1 &#x3D; 666, num2 &#x3D; -233;\nprintf(&quot;|%+d|%+d|&quot;, num1, num2);\n&#x2F;**输出结果**&#x2F;\n|+666|-233|\n\n&#x2F;**标志符 空格 演示**&#x2F;\nint num1 &#x3D; 666, num2 &#x3D; -233;\nprintf(&quot;|% d|% d|&quot;, num1, num2);\n&#x2F;**输出结果**&#x2F;\n| 666|-233|\n\n&#x2F;**标志符 # 演示**&#x2F;\nint num1 &#x3D; 170; \nfloat num2 &#x3D; 66.233, num3 &#x3D; 77;\nprintf(&quot;|%x|%f|%f|\\n&quot;);\nprintf(&quot;|%#x|%#f|%#f|\\n&quot;);\n&#x2F;**输出结果**&#x2F;\n|aa|66.233002|115|\n|0xaa|66.233002|0115|\n&#x2F;&#x2F;对于num2为什么不是66.233，这是由于浮点型存储方式造成的，更多内容请自行搜索。\n\n最小宽度用于控制变量输出的长度，对于长度不足的字符，用空格补全。但在标志符中用 0 可以使其用0补全。\nint num &#x3D; 666;\nprintf(&quot;|%5d|%-5d|%05d|&quot;, num, num, num);\n&#x2F;**输出结果**&#x2F;\n|  666|666  |00666|\n\n精度精度主要用于控制小数的位数，遵循四舍五入的原则。\nfloat num &#x3D; 66.3456;\nprintf(&quot;|%1.1f|%.2f|&quot;, num, num);\n&#x2F;**输出结果**&#x2F;\n|66.3|66.35|\n\n类型长度长度格式符为 h、l 两种，h表示按短型量输出，l表示按长型量输出。如果长度格式符与变量类型不匹配，则可能会导致错误。如：%ld 表示输出long型， %lf 表示输出double型。\nlong num &#x3D; 6666666;\nprintf(&quot;|%d|%hd|%ld|&quot;, num, num, num);\n&#x2F;**输出结果**&#x2F;\n|6666666|-18006|6666666|\n&#x2F;&#x2F;可以观察到中间的数值发生了数据溢出\n\n类型类型表示一种输出格式，但其也需要与变量类型对应，否则会出错。如：char 对应 c ，字符串对应  s ，整形对应 d ，浮点数对应  f 。\n格式字符意义d以十进制形式输出带符号整数(正数不输出符号)o以八进制形式输出无符号整数(不输出前缀0)x,X以十六进制形式输出无符号整数(不输出前缀Ox)u以十进制形式输出无符号整数f以小数形式输出单、双精度实数e,E以指数形式输出单、双精度实数g,G以%f或%e中较短的输出宽度输出单、双精度实数c输出单个字符s输出字符串\n\n这里仅需记住常用的即可，如：整型、小数、字符串。用法相信经过上面的例子演示，大家也会使用了。这里就不再演示。\n转义字符转义字符的存在，是因为C语言占用了一些字符来表示特定含义，也包括一些无法通过键盘输入的字符或命令。值得注意的是，转义字符也是字符。\n\n\n\n转义字符\n意义\nASCLL码值(十进制)\n\n\n\n\n\\a\n响铃(BEL)\n007\n\n\n\\b\n退格(BS) ，将当前位置移到前一列\n008\n\n\n\\f\n换页(FF)，将当前位置移到下页开头\n012\n\n\n\\n\n换行(LF) ，将当前位置移到下一行开头\n010\n\n\n\\r\n回车(CR) ，将当前位置移到本行开头\n013\n\n\n\\t\n水平制表(HT) （跳到下一个TAB位置）\n009\n\n\n\\v\n垂直制表(VT)\n011\n\n\n\\'\n代表一个单引号\n039\n\n\n\\\"\n代表一个双引号字符\n034\n\n\n\\\n代表一个反斜线字符'''\n092\n\n\n?\n代表一个问号\n063\n\n\n\\0\n空字符(NUL)\n000\n\n\n\\ddd\n1到3位八进制数所代表的任意字符\n三位八进制\n\n\n\\xhh\n十六进制所代表的任意字符\n十六进制\n\n\n\n\n\nscanfscanf的作用scanf是用于读取输入缓冲区的函数，表现为读取输入的内容，包括字符串和数字等。是较为常用的读取函数。\nscanf的用法与printf类似，有多个参数，相同的格式。但不同的是，读取数值或单个字符时，需要加上取地址符 &amp; 。\nint num1 &#x3D; 0;\nchar *string1;\nchar string2[10] &#x3D; &#123;0&#125;;\nscanf(&quot;%d&quot;, &amp;num1);\nscanf(&quot;%s%s&quot;, string1, string2);\n\n还有一个需要注意的地方是，scanf是严格的，即scanf会严格匹配输入的内容。\n而且scanf不会读取空格，一旦出现空格，它会认为读取完成（对于读取字符串也是如此）。因此对于读取字符串，我们常用gets而不是scanf，除非是单个单词或者单个字符。\nscanf(&quot;%d,%d&quot;, &amp;num1, &amp;num2);\n&#x2F;&#x2F;在此应该输入：13,14\n&#x2F;&#x2F;而不能输入：66 233\nscanf(&quot;%s&quot;, string1);\n&#x2F;&#x2F;在这里不能输入：I Love C Language\n&#x2F;&#x2F;否则scanf只会读取I\n\n对于读取多个数据时，scanf会以空格，TAB(缩进)，回车，或者非法字符(即与数据类型不相符的数据)作为该数据结束标志。\nscanf(&quot;%d%d%d&quot;, &amp;num1, &amp;num2, &amp;num3);\nprintf(&quot;%d, %d, %d&quot;, num1, num2, num3);\n&#x2F;&#x2F;输入：123 666A233\n&#x2F;**输出结果**&#x2F;\n123, 666, 0\n\n格式控制符对于scanf的格式控制符如下：\n%[标志][输入最大宽度][类型长度]类型\n方框 [] 的部分表示可选。\n标志符scanf的标志符据我了解，只有 * ，用于表示该输入项，读入后不赋予相应的变量，即跳过该输入值。\nscanf(&quot;%d%*d%d&quot;, &amp;num1, &amp;num2);\nprintf(&quot;%d, %d&quot;, num1, num2);\n&#x2F;&#x2F;分别输入：12 13, 14\n&#x2F;**输出结果**&#x2F;\n12, 14\n\n输入最大宽度限制输入的数字或字符串的最大长度。\nscanf(&quot;%2d&quot;, &amp;num1);\nwhile(getchar() !&#x3D; &#39;\\n&#39;);\nscanf(&quot;%3s&quot;, string1);\nprintf(&quot;%d, %s&quot;, num1, string1);\n&#x2F;&#x2F;输入：12345\n&#x2F;&#x2F;再输入：Hello!\n&#x2F;**输出结果**&#x2F;\n12, Hel\n\n类型长度和类型这两项与printf完全相同，在此就再重复了。\n高级格式控制符持续更新中…\ngets 与 putsgets 与 puts 也是一组读取输出的函数，他们与scanf和printf不同的是，他们只能处理字符串，参数只有一个，即字符串。值得注意的是gets与scanf不同，gets会读取空格，同时也不用清空输入缓冲区。\ngets(string1);\nputs(&quot;666&quot;);\n\ngetchar 与 putchargetchar 与 putchar 也是一组读取输出的函数，但只能读取和输出单个字符。getchar无参数（不要忘了括号），putchar的参数是一个字符。\nchar ch1 &#x3D; 0;\nch1 &#x3D; getchar();\nputchar(ch1);\nputchar(&#39;6&#39;);\n\n需要知道的是，虽然我们不常用这两个函数读取或输出字符，但我们常用getchar清空输入缓冲区。\n清空缓存区主要是因为用户有时候可能会多输入，不仅如此，对于scanf它读取完内容后会遗留一个回车。如果不清空缓存区，下一次就会直接读取缓冲区的内容，而不会暂停等待用户输入。\n所以每使用一次scanf，尽量清空一次缓冲区，这是一个良好的习惯。\n&#x2F;&#x2F;读取到文件结尾后才结束，可以用Ctrl + Z 手动生成文件结尾标志\nwhile(getchar() !&#x3D; EOF);\n&#x2F;&#x2F;读取到回车后结束\nwhile(getchar() !&#x3D; &#39;\\n&#39;);\n\n\n\n选择判断与布尔运算布尔运算布尔运算也称逻辑运算，即只有“真”与“假”的运算。左值与右值满足条件则为真，否则为假。\n\n\n\n运算符\n意义\n\n\n\n&#x3D;&#x3D;\n等于\n\n\n!&#x3D;\n不等于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&amp;&amp;\n与\n\n\n||\n或\n\n\n!\n非\n\n\n^\n异或\n\n\n值得注意的是，布尔运算也有优先级。\n运算优先级总结  优先级   运算符   名称或含义   使用形式   结合方向   说明   1   []   数组下标   数组名[常量表达式]   左到右   --   ()   圆括号   (表达式）/函数名(形参表)   --   .   成员选择（对象）   对象.成员名   --   -&gt;   成员选择（指针）   对象指针-&gt;成员名   --      2   -   负号运算符   -表达式   右到左   单目运算符   ~   按位取反运算符   ~表达式   ++   自增运算符   ++变量名/变量名++   --   自减运算符   --变量名/变量名--   *   取值运算符   *指针变量   &amp;   取地址运算符   &amp;变量名   !   逻辑非运算符   !表达式   (类型)   强制类型转换   (数据类型)表达式   --   sizeof   长度运算符   sizeof(表达式)   --      3   /   除   表达式/表达式   左到右   双目运算符   *   乘   表达式*表达式   %   余数（取模）   整型表达式%整型表达式   4   +   加   表达式+表达式   左到右   双目运算符   -   减   表达式-表达式   5   &lt;&lt;   左移   变量&lt;&lt;表达式   左到右   双目运算符   &gt;&gt;   右移   变量&gt;&gt;表达式      6   &gt;   大于   表达式&gt;表达式   左到右   双目运算符   &gt;=   大于等于   表达式&gt;=表达式   &lt;   小于   表达式&lt;表达式   &lt;=   小于等于   表达式&lt;=表达式   7   ==   等于   表达式==表达式   左到右   双目运算符   ！=   不等于   表达式!= 表达式      8   &amp;   按位与   表达式&amp;表达式   左到右   双目运算符   9   ^   按位异或   表达式^表达式   左到右   双目运算符   10   |   按位或   表达式|表达式   左到右   双目运算符   11   &amp;&amp;   逻辑与   表达式&amp;&amp;表达式   左到右   双目运算符   12   ||   逻辑或   表达式||表达式   左到右   双目运算符      13   ?:   条件运算符   表达式1?  表达式2: 表达式3   右到左   三目运算符      14   =   赋值运算符   变量=表达式   右到左   --   /=   除后赋值   变量/=表达式   --   *=   乘后赋值   变量*=表达式   --   %=   取模后赋值   变量%=表达式   --   +=   加后赋值   变量+=表达式   --   -=   减后赋值   变量-=表达式   --   &lt;&lt;=   左移后赋值   变量&lt;&lt;=表达式   --   &gt;&gt;=   右移后赋值   变量&gt;&gt;=表达式   --   &amp;=   按位与后赋值   变量&amp;=表达式   --   ^=   按位异或后赋值   变量^=表达式   --   |=   按位或后赋值   变量|=表达式   --      15   ，   逗号运算符   表达式,表达式,…   左到右   -- \n\n\n 总结： 同一优先级的运算符，运算次序由结合方向所决定。 简单而言： ！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符\n选择结构if 选择结构对于 if 选择结构由基本的三个语句构成，分别是：if(条件)、else if(条件) 、else 。选择结构必须有 if，但其他两个视情况而定。选择语句可以无限嵌套，简称套娃。但如果 if 选择结构超过了五层，请你好好思考，你的程序设计得合不合理。\n以下是常见的 if 选择结构语句。\nif (条件)&#x2F;&#x2F;条件即布尔运算\n&#123;\n\t代码\n&#125;\nelse if (条件)\n&#123;\n\t代码\n&#125;\n...&#x2F;&#x2F;n个else if语句\nelse\n&#123;\n\t代码\n&#125;\n\n程序先判断 if 的条件，如果满足则执行 if 中的代码，并跳出选择结构执行选择结构后的代码；如果不满足 if 的条件，则再判断第一个 else if 的条件，满足则执行其中的代码并跳出；如此判断下去，如果 if 和 else if 的条件都不满足，则直接执行 else 的代码。else 其实就相当于程序的保底。\n对于选择结构，如果只有单句代码需要执行，则可以去掉大括号，但别忘了加上分隔符。\nif (i &gt; 0) printf(&quot;6&quot;);\nelse printf(&quot;233&quot;);\n\nswitch 选择结构switch(判断的整型变量)\n&#123;\n\tcase 对应的值1:\n\t\t代码\n\t\tbreak;\n\tcase 对应的值2:\n\t\t代码\n\t\tbreak;\n\t...&#x2F;&#x2F;n个case后\n\tdefault:\n\t\t代码\n\t\tbreak;\n&#125;\n\n\n\n循环语句与结构循环是程序之所以广泛应用的根本，毫不夸张的说，循环把现代人从许多重复的工作中解脱，极大解放了生产力。现代的编程语言，基本都有选择结构和循环结构，并且他们的语句无比惊人的相同，基本每个语言都有 if 判断、for 循环、while 循环。\n但循环虽好，他也有一些需要注意的问题。如果掉以轻心，你可能会写出一个死循环，无限运行循环内的代码，导致计算机死机。\nfor 循环对于一个循环，我们很容易想出，要想循环不进入死循环，只需要初始化一个计数变量，用于记录触发的次数，再对计数变量进行判断即可。\n下面是 for 循环的基本结构\nfor (初始化代码;循环条件;单次循环结束执行的代码)\n&#123;\n\t所要重复执行的代码\n&#125;\n\n&#x2F;&#x2F;例子\nfor (int i &#x3D; 0; i &lt; 6; i++)\n\tprintf(&quot;6&quot;);\n&#x2F;&#x2F;该代码会重复执行六次输出6的代码\n\n同样的，for 循环如果只需执行单个语句，也可以把大括号去掉。\n初始化代码顾名思义就是就是在进行for循环前，执行的代码，通常用于初始化计数变量。在例子中，我便初始化了一个i变量用于计数，当然你也可以像平常初始化变量那样初始化多个变量用于计数，你也可以什么都不写，但不能少了分隔符。\nfor (int i &#x3D; 0, j &#x3D; 0; i &lt; 6; i++)\n&#123;\n\tprintf(&quot;6&quot;);\n&#125;\n\n值得注意的是，对于部分老式编译器，不支持在for循环中进行变量的声明，尤其是在学校的机房里（说的就是你大工）。这个时候就要将变量的声明放在main函数的下面。\nint main(void)\n&#123;\n\tint i;\n\n\tprintf(&quot;233\\n&quot;);\n\t\n\tfor (; i &lt; 6; i++)\n\t&#123;\n\t\tprintf(&quot;6&quot;);\n\t&#125;\n\t\n\tfor (i &#x3D; 0; i &lt; 233; i++)\n\t&#123;\n\t\tprintf(&quot;9&quot;);\n\t&#125;\n&#125;\n\n循环条件循环条件同选择结构的条件一般，即布尔运算。满足条件则继续循环，否则结束循环。\n单次循环结束执行的代码之所以要有这一步，主要是用于防止循环进入死循环。\n观察上述例子我们可以发现，我们通常将计数变量递增作为该部分的代码，用来限制循环的次数。\n当然啦，你也可以不写，直接空出来，但你就要在循环体内的代码的结尾手动写上。除非你很清楚自己在干什么。\nwhile 选择结构了解了for循环，那学会while循环更是易如反掌。他其实就相当于一个不填”初始化代码”和”单次循环结束要执行代码”的for循环。\n其实就相当于自己要另外实现这两个功能罢了。\nwhile (循环条件)\n&#123;\n\t所要重复执行的代码\n&#125;\n\n&#x2F;&#x2F;例子\nint i &#x3D; 0;\nwhile (i &lt; 6)\n&#123;\n\tprintf(&quot;6&quot;);\n\ti++;\n&#125;\n\ndo...while... 循环do...while... 循环其实就是先执行一边再判断的 while 循环，与while循环并无太大不同。\n但别忘了 while 后有分号。\ndo\n&#123;\n\t所要重复执行的代码\n&#125;while(循环条件);\n\n\n\n数组对于一维声明数组时初始化，可以不用标明元素个数。对于方括号内的值，仅能为正整数常量及其表达式。\n多维数组对于n维数组，至少要定义n-1维的长度，且定义的维度必须为低维度（即排后面的维度），否则无法初始化。\n数组与字符串\n函数对于函数而言，它可以嵌套调用，但不能嵌套定义。\n返回值不论return所返回的值的类型是什么，返回值都会转化为函数类型相同的类型。\n\n字符串处理strcpy函数strcat函数\n文件处理fopen函数FILE *fopen(const char *filename, const char *mode)\n\n\n\n模式\n描述\n\n\n\n“r”\n打开一个用于读取的文件。该文件必须存在。\n\n\n“w”\n创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。\n\n\n“a”\n追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。\n\n\n“r+”\n打开一个用于更新的文件，可读取也可写入。该文件必须存在。\n\n\n“w+”\n创建一个用于读写的空文件。\n\n\n“a+”\n打开一个用于读取和追加的文件。\n\n\n“rb”\n打开一个用于读取的二进制文件，该文件必须存在\n\n\n参考资料C语言输出格式控制符汇总转义字符对照表C语言运算符优先级（超详细）C语言格式输入函数scanf()详解scanf()函数中高级格式控制符用法菜鸟教程——C语言\n","slug":"C语言基础学习笔记","date":"2023-04-29T13:16:43.000Z","categories_index":"C语言","tags_index":"C语言,总结","author_index":"司空绝洛"},{"id":"aece1410b59afa81265317d299da61a4","title":"Keil STM32F4 标准外设库的本地环境搭建","content":"Keil STM32F4 标准外设库的本地环境搭建\n一些废话怎么说，STM32的库环境搭建，是我见过最难搭建的环境了，比C语言过犹不及。你能想象花了几个小时就是为了处理环境搭建时的各种报错吗？只能说环境搭建是开发者的痛啊。\n\n关于标准外设库和HAL库HAL库是近些年STM主推的库，而标准外设库是之前的库。目前而已HAL库通用性更强，能适配几乎所有STM32芯片，但标准外设库通用性更差一些，基本不太可能跨芯片使用。但HAL库的运行速度也因此比标准外设库更慢，因此目前也有不少人仍然使用标准外设库，大多教程也是基于此。然而官方已经不打算更新标准外设库了，有些新出的芯片甚至没标准外设库，因此HAL成为主流也是迟早的事。\n但其实HAL库也没有那么不堪，抛开运行速度，几乎其他全是优点。它有着官方配套开发工具，包括CubeMX和CubeIDE，且全部免费，可以省去很多配置环境的操作，以及更好看的UI，较好的汉化。如果使用HAL库开发，建议使用CubeMX和CubeIDE，可以省去很多麻烦。\n\n前期准备Keil5用来开发单片机的IDE，仅有部分代码补全，且UI极其丑陋，但它的编译调试和下载却又不可替代。有时候最新版不一定就好，最新版不内置ARMCC5，而标准外设库又是基于此搭建的，但恰好ARM已经不提供旧版本的ARMCC。因此建议安装旧版本，如果实在想用新版本，可以先装旧版本，再装新版本，覆盖旧版本。\n标准外设库可以在STM官网下载，中国官网和外网都行。\n\n选择产品\n\n标准外设库\n\n\n标准外设库的环境搭建库函数本地化新建一个工程文件，并在工程文件下建立 User、Libraries、Start 文件夹。其中 Start 用于存储启动文件，Libraries 用于存储库文件，User 则用于存储用户文件（即程序源代码）。当然，你也可以根据自己的风格建立文件夹，但前提是记得文件放在哪。\n\n同样在Keil中建立相同的文件夹。\n\n在该目录下，找到对应型号的启动文件，并拷贝到 Start 文件夹下。一般 F40x~F41x 的，一般选择 f40_41xxx 。\n\n同样在该目录下拷贝选中的文件到 Start 。\n\n将下面两个文件拷贝至 Start 。\n\n将以下文件拷贝至 Start 。因为 F4 一般为 Cortex-4  的内核，因而选择 cm4 文件。如果为其他系列则看提示拷贝，先拷贝内核文件，编译后看报错缺啥就拷贝啥即可。\n\n以上完成后，即可使用寄存器开发STM32。但库函数仍需拷贝 inc 和 src 目录下的所有文件至 Libraries 。\n\n\n将以下文件拷贝至 User 。\n\nKeil 的配置依次将文件添加进 Keil 的工程。\n\n打开工程设置。\n\n生成器换为ARMCC5。\n\n勾选才 c99 模式。\n\n如果是ARMCC6，这显示如下界面。\n\n打开 stm32f4xx.h ，根据提示选择相应的数据添加到宏定义中。\n\n\n同样在 stm32f4xx.h ，找到并添加库函数的宏定义。两个参数之间用 , 隔开。\n\n\n在 Keil 中添加包含目录，不然 Keil 只会从安装目录寻找文件，他就找不到本地的文件。\n\n\n在 User 下建立一个 main.c 文件，注意路径设置，默认在User外，与工程文件同目录。\n\n\n编写基本的代码。注意最后一行空行，否则可能无法编译。\n#include &quot;stm32f4xx.h&quot;                  &#x2F;&#x2F; Device header\n\nint main(void)&#123;\n\n\twhile(1)&#123;\n\t\n\t&#125;\n\n&#125;\n\n\n如果你是F407，现在编译，必然报错。报错说是函数未定义，但其实是板子不同，引用的 .h 头文件不同，导致函数未定义。这个文件主要是给支持动态SDRAM的板子（F429、F7,H7系列等）用的。直接在工程中删去相应的 .h 和 .c 文件即可。\n\n\n还有一个报错，其实是为了消除报错贸然拷贝官方 main.h 文件所造成的。\n\n可以将官方案例中的 main.c 文件相关的函数复制到main.c中。但我比较推荐直接复制到stm32f4xx_it.c 的开头中，然后再删除 main.h 文件，以防跟自己写的函数搞乱。\nstatic __IO uint32_t uwTimingDelay;\n\nvoid TimingDelay_Decrement(void)\n&#123;\n  if (uwTimingDelay !&#x3D; 0x00)\n  &#123; \n    uwTimingDelay--;\n  &#125;\n&#125;\n\n至此，标准外设库的环境搭建就圆满完成了。接下来就可以继续嵌入式头秃之旅了。\n","slug":"Keil STM32F4 标准外设库的本地环境搭建","date":"2022-11-02T13:32:12.000Z","categories_index":"嵌入式","tags_index":"Keil,教程,嵌入式,STM32,环境搭建","author_index":"司空绝洛"},{"id":"35de80971299a8a8696090efdf015d76","title":"Windows + Deepin 单硬盘双系统的安装与使用","content":"Windows + Deepin 单硬盘双系统的安装与使用说实话我受够了Windows的环境搭建，想要精简就极度繁琐，想要方便就得用宇宙IDE，占十几二十多GB存储。因此，Linux就是最好的选择，除非你需要写Win或Mac的软件等特定情况。\n那为什么选择 Deepin ？首先因为它可以较为方便的下载和安装 Linux 软件，省去了较为麻烦的适配和编译过程。其次是因为它比较符合 Windows 的使用习惯，UI风格偏向于Mac，较为美观。我觉得作为一个初学者，Deepin 确实算是一个较为不错的选择。\n至于为何不用虚拟机。它虽然安全且方便，但由于性能的限制，会导致运行起来时不时卡顿，这实在谈不上是一个良好的体验。且似乎会导致物理本机性能下降（存在争议），因而不考虑用虚拟机。\n说是双系统，其实就是装系统，只不过多了一些步骤罢了。\n关于单硬盘双系统与多硬盘多系统。值得说明的是硬盘不等于磁盘，硬盘可以被分为多个磁盘，这个过程也就是所谓的分区。硬盘是物理上的，磁盘是硬盘被虚拟地划为多个区域，分别进行管理。\n多硬盘多系统指的是将多个系统装在大于等于两个硬盘内。系统的启动需要引导程序，每个系统都会有一个引导程序。一般而言，引导程序能够检测到同一硬盘下的所有系统，而难以检测到不同硬盘下的系统，因而多硬盘多系统需要额外的配置。（如果感兴趣可以自行搜索双硬盘双系统引导）\n\n准备相关物品及文件U盘对于速度无要求，但容量至少8GB以上，以保证能完成启动盘的制作。\nDeepin 的系统镜像Deepin 官网下载系统镜像。如果你不介意 bug 和生态，也可以下载预览版。\nDeepin 启动盘制作工具同样在Deepin 官网下载启动盘制作工具。\n\n启动盘的制作选择系统镜像。\n选择U盘和格式化，注意备份。然后就可以制作启动盘。\n\n系统盘分区使用分区助手对硬盘进行分区。（也可使用其他分区软件）\n具体容量建议为 32GB+32GB+8GB 以上。其中 32G 为系统盘，另外的32GB是资料盘，8G 为交换分区。交换分区是 Linux 的虚拟内存，一般容量与内存相同，内存 16G 以上可不设，但有交换分区可以使用休眠功能，可加快 Linux 启动速度，这取决于你用不用休眠。\n可以先拆分出一个分区。\n\n再将该分区删除。\n\n即可得到一个空白分区。\n\n\nBios 的设置插入启动盘，启动时按 Delete 进入 Bios 界面。（不同主板有不同按键，请自行上网查询）进入启动界面，更改启动顺序，将启动盘启动顺序改为第一位，保存并重启即可正常进入启动盘安装 Deepin 。\n或者按 F12 手动选择启动盘启动。（不同主板按键不同）\n\n安装 DeepinDeepin 毕竟是国产系统，对中文支持比较完善，选择简体中文即可。\n硬盘分区部分选择手动安装。选择空白分区后，点击右方的编辑按钮。\n\n先建立一个 efi 引导分区。大小最低 300MB 即可。\n\n\n\n\n\n\n\n\n\n其实不建立 Deepin 的引导分区也是可以的，但如果 Windows 的引导分区废了，那很可能两个系统都会无法启动。而且如果后续你还要安装 macOS 或者 Ubuntu ，可能会导致 Deepin 无法被引导程序发现。总之在国内互联网少有相关的资料的情况下，不建议这样做。\n\n建立一个交换分区。\n\n大小等同于内存大小。\n\n系统盘则分配 32GB，挂载在根目录，文件系统选择 ext4 。\n\n\n\n\n\n\n\n\n\n其实剩下的都可以分配给系统盘，但我建议还是分一些给数据盘。这样系统盘崩溃后，不至于重装系统后，还要配置一次软件。\n\n剩下的分配给数据盘，挂载在 &#x2F;home 目录下。文件系统可以选择 ext4 或者其他，这里我想体验一下其他文件系统，因而选择 btrfs 。\n\n如果一切正常就点继续安装即可。但注意不要勾选集成NVIDIA闭源驱动，后面我们自己安装即可，这玩意存在问题。\n\n如果你不需要休眠功能，且内存也足够，并没有分配交换分区，则会出现提示，忽略即可。\n\n安装完成后，再次进入Bios，将硬盘启动顺序改为 Deepin 优先。\n\n\n初始化 Deepin重启后，在Grub界面等待几秒，自动进入 Deepin 。\n选择语言，简体中文，并勾选同意协议。\n\n键盘布局同样简体中文。\n\n时区选择北京。\n\n选择头像，输入用户名等信息。待其初始化完成后即可。\n\n\nGrub 美化可以在 gnome-look 上的 GRUB themes 上找到自己喜欢的主题。下载后根据说明进行安装即可。（基本就是运行脚本就可自动安装，除非你想自行安装）\n\n\n\n\n\n\n\n\n\n如果不想切换终端工作目录，那就在主题目录右键打开终端。初识Linux的可以查看主题 README 给出的相关命令。\n\n如果无法下载，可以去寻找其 GitHub 镜像，常在标题处见。\n\n\nNVDIA驱动安装直接去官网上选择linux版下载即可。\n","slug":"Windows-Deepin-单硬盘双系统的安装与使用","date":"2022-10-04T11:03:09.000Z","categories_index":"Linux","tags_index":"Deepin,Window,系统,双系统","author_index":"司空绝洛"},{"id":"02b162bfeafa9edce78b0e44f29c6cee","title":"因未完全卸载导致的npm error EEXIST","content":"在安装PicGo-Core的时候，因为一直安装不了插件，于是导致我经常安装卸载PicGo-Core。\n在某次安装的时候突然失败，上网查了一下原因，说是拒绝安装。\n思考了一下，觉得有两种原因：\n第一种，没有管理员权限\n第二种，后台程序占用文件\n然而解决这两个因素后，PicGo仍然安装不了，仔细观察错误信息后发现，npm叫我删除某个文件然后再重试。\n\n我在npm的安装文件夹找了一下，找到了未完全卸载的picgo文件，删除后就可以正常安装了。\n","slug":"因未完全卸载导致的npm-error-EEXIST","date":"2020-04-18T11:48:28.000Z","categories_index":"Error","tags_index":"PicGo,npm,Error","author_index":"司空绝洛"},{"id":"b3b8e47aba5c4a70134513d550c963fd","title":"Obsidian 或 Typora + Picgo + smms 实现图片自动上传","content":"Introduction——前言\n\n\n\n\n\n\n\n\ntypora写作是很舒服，但是到了图片上传我简直太难了。上一篇博客我说我图床用的是imgchr，现在我屈服了，玩博客用imgchr简直是魔鬼好吧，图片上传完了，居然是乱序上传，导致我很难改图片地址。又因为imgchr每小时30张（根据服务器负载情况调整，大部分图床都有限制），而我图片都是一次全传完，所以就免不了被限制。\n所以后来我就找了个法子——typora + picgo，自动上传图片，这样就可以避免图片都是同一时间传，本来我是想自己开发picgo + imgchr 的插件的，研究了半天，发现imgchr没有api，这就很尴尬了，所以最后只能选择SM.MS作为博客的主要图床了。\n——2020&#x2F;04&#x2F;18\n时过境迁，物是人非，没想到没过几年这个教程就有些过时了；也没想到 smms 那么快就被墙了；更没想到 Typora 居然收费了。由于学业停更两年的我，终于又回归了。我在原来教程的基础上增加了Obsidian的设置，以及smms被墙的一个解决方案，其实这也是我重新开始所遇到的问题，希望对后来者有一定的帮助吧。\n\nPreparation——前期准备Obsidian新晋之星，Markdown 编辑器的清流。对个人不收费，但对团队收费。他对于多文档管理非常友好，但也因此对单文档异常不友好，必须新建库，才能编辑文件。但由于其携带大量插件，使得功能极大丰富，写作的舒适程度也不亚于 Typora ，也是一款能与传统笔记本界对抗的笔记软件。其特色功能——双向连接，使其具有 Notion 的风味。用来做大型教程或者官方文档翻译十分顺畅。\nTypora这个就不用多说了吧，Markdown写作神器，无需知道任何 Markdown 语法也能用的 Markdown 编辑器。与Obsidian较大的差别可能是付费且无双向连接，不太适用多个文件管理，但对于单个文件的处理较好。\n\nNode.jspicgo有两个版本，一个是CLI版本一个是GUI版本的(CLI版本即PicGo-Core，GUI版本即PicGo.app)。而我使用的是CLI版本的，也就是命令行版本的，可以减少常驻内存的占用。\n注意：根据Picgo官方文档的描述，要求Node.js 版本 &gt;&#x3D; 8。\n\n\n\n\n\n\n\n\n\nPicGo.app和PicGo-Core之间的区别（命令行）\n目前，PicGo（应用程序）仅中文。\nPicGo.app提供了一个GUI，因此与CLI版本相比更易于设置。\n使用PicGo-Core（命令行）进行上传会消耗较少的计算资源，因为该过程仅在上传过程中运行，并且在上传成功或失败后将退出。通过PicGo.app上传时，PicGo.app将始终保持运行状态，不会自动退出。此外，PicGo.app是电子应用程序，它消耗了更多的计算资源。\nPicGo.app和PicGo-Core使用不同的配置文件，但是您可以将picBedPicGo.app的配置文件中key 下的json对象复制到PicGo的配置文件中。\nPicGo.app提供其他功能，例如上传历史记录，自动重命名等。\n\n——typora官网文档\nPicgopicgo-core以下简称picgo。\n安装在任意目录打开Git Bash或者cmd等等，输入命令安装。\nyarn global add picgo\n\n# 或者\n\nnpm install picgo -g\n\n觉得安装慢的，我上一篇博客也有讲到，将 npm 切换到淘宝源或其他可用源即可。\n检验picgo -h\n\n# 或者\n\npicgo -v\n\n输出如图所示即为安装成功。\n\n\n\n\n\n\n\n\n\n\n\nPicGo 本体支持如下图床：\n\n微博图床 v1.0 微博图床从 2019 年 4 月开始进行防盗链，不建议继续使用\n七牛图床 v1.0\n腾讯云 COS v4\\v5版本 v1.1 &amp; v1.5.0\n又拍云 v1.2.0\nGitHub v1.5.0\nSM.MS v1.5.1 由于官方不再支持V1版本，暂时请使用smms-user插件\n阿里云 OSS v1.6.0\nImgur v1.6.0\n\n**本体不再增加默认的图床支持。你可以自行开发第三方图床插件。详见 PicGo-Core**。\n——PicGo\n\n\n\n\n\n\n\n\n\n为 PicGo 开发的一款插件，新增了SM.MS注册用户 图床。 使用SM.MS V2的API上传，适用于注册了SM.MS的用户。填写Authorization即可\n——smms-user作者\n由于 Picgo 本体不支持 SMMS API v2，因此我们得自行安装一个插件来解决此问题。根据PicGo文档的描述，我们得用picgo install [name]来安装插件，其中 [name] 代表的是插件名\n注意：picgo的插件普遍以picgo-plugin-[name] 来命名，但安装插件时 [name] 不是 **picgo-plugin-[name]**，它不需要前面的那一部分。\n上面也说了，本体自带的smms不能用了，想要用SM.MS图床就得安装smms-user插件。\n安装smms-user插件，只需执行picgo install smms-user安装即可。安装完后，默认是开启插件的，无需另外操作。\n\nSM.MS所以我们需要一个SM.MS的密钥。\n可以百度搜索，或直接进入SM.MS的官网，注册一个账号。\n\n登录后，进入个人的设置页面。\n\n进入API Token页面，生成密钥，新注册的是没有密钥的。生成完后就会出现在Secret Token里面。\n\n\nSetting——配置Picgo 配置方法一如果不想用 SMMS 可以通过 picgo use 切换图床，在此不详细说明。\n在命令行中输入 picgo set uploader 配置 SMMS API Token。上下方向键选择，回车确认，再根据提示填写密钥即可。不会，多尝试，大不了Ctrl + C 中断，再来一遍。\n\nPicgo 配置方法二在个人用户的文件夹进入 .picgo 文件夹，打开 config.json 进行配置。\n\n修改如下，注意将Authorization的参数换为SM.MS的密钥，即将Secret Token替换为密钥。\n&#123;\n  &quot;picBed&quot;: &#123;\n    &quot;current&quot;: &quot;smms-user&quot;,\n    &quot;uploader&quot;: &quot;smms-user&quot;,\n    &quot;transformer&quot;: &quot;path&quot;,\n    &quot;smms-user&quot;: &#123;\n      &quot;Authorization&quot;: &quot;Secret Token&quot;\n    &#125;\n  &#125;,\n  &quot;picgoPlugins&quot;: &#123;\n    &quot;picgo-plugin-smms-user&quot;: true\n  &#125;\n&#125;\n\n\n关于 SMMS 被墙的解决方法由于某种不可抗力，sm.ms 目前被墙。但作者后来上架了备用域名，即 smms.app 。插件默认是使用备用域名的，但如果仍无法正常上传，那你可能需要修改一下 picgo 的配置文件。\n打开 picgo 的配置文件。\n\n搜索 sm.ms ，将网址更换为 smms.app 即可。\n\nObsidian 的配置Obsidian 并没有自带图片上传的功能，我们需要自行去社区下载。\n打开 Obsidian 的设置，关闭安全模式，即可打开社区插件市场。\n\n如果你无法正常浏览插件，那么你可以安装ProxyGithub插件实现正常访问。GitHub 打不开也可以用 Gitee 。\n搜索 Image Auto Upload Plugin 安装插件，当然你也可以像 ProxyGithub 那样手动安装。\n\n最后将插件的默认上传器修改为 Picgo-Core 即可，如果你并非默认目录安装 Picgo ，那请记得修改路径。\n\nTypora打开typora，进入偏好设置。\n\n进入图像选项，将 插入图片时… 更改为上传图片，勾选对本地位置的图片应用上述规则、 插入时自动转义图片URL 。至于第二项我不推荐勾选，因为当你写博客时，想将上传好的图片更换位置，一复制一粘贴，它又给你上传了一遍…当然，如果你想用我也不会阻拦。\n\n\n\n\n\n\n\n\n\nIf you have “node” and “picgo” installed in system PATH directly, you could also fill “picgo upload” as the custom command directly.\n——typora官方文档\n根据官方文档的描述：因为我不是使用typora内置下载的picgo CLI版，所以我们得自定义命令。我们需要将上传服务改为Custom Command，然后在自定义命令里输入picgo upload 。\n\n至此所有的配置都完成了，之后就可以愉快的使用了。\nUsage——使用官方文档其实是有说明如何使用的，不过我还是演示一下吧。\n截图截图粘贴需要手动上传，当然啦这可能是为了避免我之前说描述的情况吧。\n\n拖拽拖拽就不用手动上传了，他会自动上传\n\n","slug":"Obsidian 或 Typora + Picgo + smms 实现图片自动上传","date":"2020-04-18T09:57:12.000Z","categories_index":"博客","tags_index":"教程,Typora,博客,PicGo,图床","author_index":"司空绝洛"},{"id":"bbd723d7a030c0131f233ffce27b57ad","title":"github + hexo博客搭建教程","content":"Introduction——前言托更了很久，我一点不好意思都没有[手动滑稽]，我想应该没有人等着我的教程的吧。之所以这时才做这教程，是因为我准备开启新项目了，如果还不填坑的话，坑就越来越多，然后就不想填了。为了避免这种情况，所以我决定先填了这坑，再开新坑。\n本篇文章将会一步步教你如何用github和hexo搭建属于自己的博客，以及搭建过程中的一些注意事项，也会教你如何解决搭建过程中出现的问题，我不仅仅会提供一种解决问题的方法，还会提供一种解决问题的思想。\n因为我早就搭建好博客了，所以为了模拟搭建过程和搭建过程所遇到的问题，我选择虚拟机来模拟这一效果。或许我可以不那么麻烦，但是我的记忆力实际上是不怎么好的，更何况现在距离我搭建完博客已经很久了，有些细节我都忘了，而这些细节又很重要。所以为了最好的效果，我就决定麻烦一些，既方便我以后的复习，也方便大家。\nPreparation——准备工作在这里，我将告诉你用github pages + hexo的方式搭建博客所需的一些前置要求。当然啦，平台是windows，linux以后再说吧。\ngithubgithub 就不用多说了吧，想要用github pages 那就就免不了一个github的账号，当然有了就不用注册了，可以直接跳过。\ngithub是全英文的，我怕有的人看到英文就头疼，所以我就给一个注册的步骤吧。如果用谷歌浏览器的，直接用谷歌翻译后问题就不大了。下面我就教一些不用谷歌浏览器的人github的注册方法。\n打开github在网页的地址栏输入github的官网github.com，然后回车。\n\n打开注册页面在github的官网上头点击Sign up打开注册页面。\n\n输入信息并注册\nNode.jsHexo是基于Node.js开发的，所以要安装hexo，Node.js必不可少\n打开官网老司机可以直接跳过了。\n可以百度搜索Node.js，或者直接打开nodejs.org\n\n在右上角找到一个像谷歌翻译的图标，点击后，找到 **中文(简体)**并点击，即可更换语言。百度搜索到的一般是已经调好语言了的，所以不在需要更换语言，可以直接跳到下一步。如果对英文不敏感的话，也可直接省略。\n\n下载Node.js官网提供两个版本，一个最新版(即当前发布版)，和一个稳定版(即长期支持版)。个人建议下载稳定版，当然你想要最新版也没问题。\n\n安装安装没什么好说的，双击运行后，一路默认安装即可。完成后如图所示。\n\n检验安装安装后，就免不了检验是否安装成功。打开命令行，即win+r，输入 cmd，回车。即可打开命令行。\n\n然后在命令行中输入node -v，回车后，输出结果为版本号，说明node.js安装成功。\n\n在命令行中输入npm -v，回车后，输出结果为版本号，说明npm安装成功。\n\nGitgit是一个好东西，他有挺多用处，但我都不懂用。如果想了解更多，请去廖雪峰老师的官方网站。不要害怕不精通就不会用，虽然我们不精通也不了解，但这并不妨碍我们使用它。\n下载首先打开Git的官方网站，同理你可以百度搜索，也可以直接打开git-scm.com进入官网。看到绿色的小电脑没有？点击下方的download即可下载。\n\n当然啦，因为是外国网站，下载速度是非常慢的，下面提供一个办法，打开阿里源的镜像站（注意我提供的网址仅限windows平台的Git），下滑找到最新版本，并点击。\n\n找到自己的操作系统类型，是32位还是64位。选择好后，点击下载。\n\n安装安装也是跟node.js一样，全部默认，毕竟看不懂英文嘛[手动滑稽]。\n\n检验安装安装完后，自然也免不了检验，老司机就跳过吧。\n同样打开命令行，即win+r，输入 cmd，回车。在命令行中输入git --version，回车。看到输出版本号即为安装成功。\n\n或者直接在桌面右键看到Git GUI Here和Git Bash Here即为安装成功。\n\nHexoHexo在我看来就是一个将Markdown按照模版转换为网页的工具。\n\n\n\n\n\n\n\n\n\n什么是 Hexo？\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n——hexo官方文档\n注意我提供的Hexo安装方法有两个，第一个是官方的安装方法，但是众所周知，因为国内的原因，所以下载速度十分缓慢，我并不推荐，所以我提供了第二个方法，利用阿里源的镜像，加快下载速度。当然这两种方法我都会在虚拟机上模拟，尽可能地排除问题。\n必要准备首先你需要找个位置新建一个文件夹，这个文件夹就是以后博客所在的文件夹。那里有hexo、hexo的主题、博客的文章等等文件，可以说那个文件夹就是本地博客与github pages的桥梁，所以必须找好地方。\n比如我，就直接反正D盘，命名为Blog。而在虚拟机中，因为我只是模拟效果，所以很随意地反在桌面。\n\n安装方法一现在我们已经创建好了文件夹，进入文件夹后，右键打开Git Bash Here\n\n在打开的命令行中输入npm install hexo-cli -g，回车。之后它就会自动下载文件，等待它命令运行完成即可。\n\n运行完成后，显示如图所示，仅供参考。\n\n然后输入hexo init，回车后继续等待。结果仅供参考。\n注意：不要中途退出或者ctrl+c停止运行命令，不然会出现一定的错误，这时候将文件夹里的文件清空，再重新运行命令。如果中途下载没有速度或者没有进展，也可用此方法，可能会有一定的效果。\n\n接下来检查一下目录，如图所示，会有以下文件和文件夹。\n\n检查完后，在命令行中运行npm install。结果如图所示。\n\n之后运行hexo s，复制提供的本地博客链接，在浏览器中打开。\n\n如图所示，即为安装成功。在命令行中按ctrl+c停止运行命令。\n\n安装方法二进入文件夹，右键打开Git Bash Here\n\n在打开的命令行中运行npm config set registry https://registry.npm.taobao.org，切换到淘宝源。\n注意：npm config set registry http://www.npmjs.org切换官方源。\n切换完后可用npm info underscore检测是否已经换到淘宝源，看到有淘宝地址，即切换成功。\n\n之后就跟方法一同样了。下面我就不重复了，就放一些效果图吧。\n\n\n\nGithub And Hexo Setting——Github和Hexo的设置做了这么久的前期准备，下面终于到正片了。现在我也算是为什么很多教程都没有这么详细的缘故了，真是废时间啊。\n其实配置ssh key和创建github pages顺序是了调换的，但配置_config.yml必须放在这两个之后，看了就懂了。\n配置SSH Keyssh key在某种程度上就是一个登录github的密钥，但它实际上并不是，它实际上是github验证用户身份的身份证。有了ssh key，git才能上传文件到用户的仓库，没有ssh key也可以布置博客，只不过会非常麻烦，全部都要手动上传。\n检查ssh key在命令行中输入cd ~/.ssh，即可检查是否创建过ssh key，如果没有则会提示找不到文件，如图所示。\n\n如果创建过ssh key，则任何提升都没有，但工作目录会移动到ssh，所以要注意，不要没切回去就乱输命令。\n\n如果已经创建，可以通过cat ~/.ssh/id_rsa.pub查看ssh key。\n\n创建ssh key如果没有创建过ssh key则首先需要全局配置git的本地用户。理论上本地用户可以随意配置，但是我建议输入的是github的信息，不然以后容易遗忘。\ngit config --global user.name &quot;用户名&quot;\ngit config --global user.email &quot;邮箱地址&quot;\n\n配置完成后执行下面的命令生成ssh key，中途需要输入三次回车。\nssh-keygen -t rsa -C &#39;上面的邮箱&#39;\n\n\n创建完后通过cat ~/.ssh/id_rsa.pub查看ssh key。\n\n添加信任打开github的账号设置\n\n新建ssh key\n\n输入必要的信息，选择添加ssh key即可。注意输入的ssh key包括**ssh-rsa **这一部分。\n\n检验想知道是否成功配置ssh key，在git bash中输入ssh -T git@github.com（注意大小写）。出现“You’ve successfully authenticated, but GitHub does not provide shell access.”则说明添加成功。\n\n创建Github pages首先登陆github，在右上角点击加号旁的倒三角，选择New repository。\n\n填好仓库的信息（公共仓库与私人仓库随意选择），然后创建，创建完后自动开启github pages。\n注意：仓库名只能和用户名相同并且要加上**.github.io，比如我的用户名为Selcon123，我的仓库名只能为Selcon123.github.io**，这是因为github只给用户一个与用户名相同的仓库开启github pages。\n\n配置_config.yml在博客的文件夹中打开_config.yml，在最下面找到deploy，并进行修改，如图所示。\n\n特别注意：输完仓库名后还要加上**.git，举个例子，假如我的用户名为Selcon123**，我需修改为\ndeploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;Selcon123&#x2F;Selcon123.github.io.git\n  branch: master\n\nDeploy Website——部署网站在这里我打算介绍一些指令，但从这里开始我就不模拟了，因为我的博客已经搭好了，如果模拟的话可能会出现一些问题。\nhexo官网提供挺多方法部署网站，但我只讲一种，如果想用其他的方法，可以执行研究。\n使用git部署首先先在git bash中，运行npm install hexo-deployer-git --save安装插件。如果在之前安装hexo时用方法二切换了阿里源，安装应该挺快。\n\n安装之后就可以用git部署了，也就是可以在博客文件夹中打开git bash，运行命令部署。以下即常用命令合集。\nhexo clean\t\t\t\t\t#清空缓存（有时候出问题时用到）\nhexo g\t\t\t\t\t\t#生成页面（缓存）\nhexo d\t\t\t\t\t\t#部署\nhexo g -d\t\t\t\t\t#生成并部署\nhexo s\t\t\t\t\t\t#本地预览（要先生成）\n\n下面是hexo自带的常用命令\nhexo new &quot;文章名&quot;\t\t\t#新建文章（博客）\nhexo new page &quot;页面名&quot;\t\t#新建页面（常用于个性化）\n\n\n\nWriting——正式写作下面我就介绍一整套写作流程流程。\n新建文章首先在git bash中执行hexo new “My first blog”新建一篇名为My first blog的文章。在**.&#x2F;source&#x2F;_posts**中找到并编辑，可以用windows自带的文本编辑器编辑，也可用其他。\n写作语法.md的文件格式说明了它的身份，它是一个Markdown格式的文本，一种对程序员比较友好的文本格式，但必不代表普通人就不懂用了，什么都是可以学习的嘛。\nMarkdown我这里并不会教如何用Markdown，我只会讲如何学习Markdown。\n推荐菜鸟教程的Markdown教程，有关命令介绍得很清楚，很适合新手，当然我也是从那里学习的。\n学习完了Markdown，就可以使用其他软件快速地编辑文章，我推荐typora，它是一个优秀的Markdown文本编辑器。但是并不推荐新手直接就用这个编辑器，因为它太优秀了，以至于把Markdown的门槛给抹去了，这样其实对个人的成长并不怎么好。工具终究是工具，最好用的还是自己的脑袋，过度依赖工具，会使自己变成工具的“工具人”。\nhtmlMarkdown是支持部分html标签的，但不是支持html。至于支持什么，自己查吧。\n图片相关图片这种基本老生常谈了，其实就是图床的问题。其实图片可以上传到github的仓库上，但是github的速度众所周知，所以比较推荐其他的图床。图床这种东西网上找一大片，但最重要的是稳定和速度。稳定就不用说了，要是几天这个平台就没了，那就欲哭无泪了，所以尽量选择老牌，而且最好是能看到他的盈利模式，一般免费的容易死的快。速度这个就更不用说了，要是速度还不如github那就呵呵了，所以尽量选择国内的吧，国外的一般在国内速度都不是很好，当然说不定也有例外。\n像我的话，用的是路过图床，2011年的，国内的，速度还行，盈利靠广告和企业收费，所以就比较令人放心。但唯一可惜的就是每小时只能传30张，每张不能超过10M。\n上传到博客在git bash执行hexo g -d部署到博客即可。\n自定义域名绑定因为我并不打算自定义域名（其实是没钱），所以我并不会自定义域名，可能以后有机会在写一下吧，在这之前可以百度学习。\n后话至于个性化的内容可能要等以后了，这篇文章也四千多字了，以后的个性化内容也不少，可以说是一个坑分成两次部吧，预告一下个性化的内容：404自定义，音乐播放器，主题更换，站长配置，评论系统，百度自动推送，广告添加，特效等等。如果等不及了可以自行解决，也可以拿钱砸我（明示打赏！），叫我更快点，反正我都不介意[手动滑稽]。如果看来我的教程还是不懂的话，可以到Hexo的官网查看文档学习。\n本来是想一天就解决了的，没想到事情突然变多，一直拖了三天左右，这也是没办法的事。之所以想要补了这个坑，是因为我想开新坑，至于是什么新坑，拭目以待吧。\n如果有什么错误，欢迎指出。\n","slug":"github-hexo博客搭建教程","date":"2020-04-05T05:35:19.000Z","categories_index":"博客","tags_index":"教程,博客,Hexo","author_index":"司空绝洛"},{"id":"361e23cf6278c16693458b1cc0fa732f","title":"Hello world","content":"第一篇博客文章\n\n\n\n\n说实话，其实这个博客早就搭好了，只不过我太懒了，搭完后没有继续完善，所以就还没公布，不过现在感觉整得差不多了，也就公布一下我的博客。\n我会在这里发一些各种各样的教程，比如自己搞的一些小程序（不是微信的啊），或者ps教程，网络工程，单片机什么的。最近的项目的话，就是公布我搭这个博客的过程，还有教程吧，当然我很懒的（不信的话可以看看上方的发表时间和更新时间），所以不要期望太多，更何况现在也有很多教程了，所以多我一个不多，少我一个不少。这个网站我是不打算被搜索引擎收录的，所以我的博客是不会被搜索到的，除非有人提交上去————所以啊，赶紧收藏啊！(&gt;▽&lt;)！\n这个网站是用 github pages + hexo 做的，因此我的博客是静态网页。当然，这个网页的主题也不是我制作的，我也没这个实力，我只是改了配色拿来用的，教程会写到的，网页最下面有原作者的网站你们可以看一下。所以以后我可能会学习制作主题，做一个属于自己的主题，毕竟这个主题也不是很适合我。\n总的来说，这个博客就是给我自嗨的，用来写写总结，发表一些看法，基本不用考虑别人，当然如果人数很多的话，我还是会考虑一下的。当然如果有人打赏的话，嘿嘿嘿，这个好说。︿(￣︶￣)︿\n","slug":"hello-world","date":"2020-03-05T04:58:02.000Z","categories_index":"生活","tags_index":"生活","author_index":"司空绝洛"}]